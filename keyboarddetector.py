#!/usr/bin/env python
#
# Disable trackpoint device when keyboard is used.
#
# Derived from original by gcla:
#  https://bugs.launchpad.net/ubuntu/+source/linux/+bug/606238/comments/39
#
# Philip Aston 19th Feb 2010
#  - Auto detect keyboard and trackpoint devices.
#  - Auto detect 32-bit/64-bit processors.
#  - Don't disable trackpoint for modifier keys.
#
# No warranty - use at your own risk.
#
# Directly accesses input devices, so must be run as root
#   e.g. sudo keyboarddetector.py

# Update by Ian Ozsvald, August 2011
# Script originally from: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/606238/comments/41
# This update fixes two OSError exceptions and adds a 'close' call (which stops one of the exceptions)
# Related docs here: http://ianozsvald.com/2011/08/02/dell-e6420-with-ubuntu-10-10-maverick-meerkat-32-bit/

import os, sys, signal, subprocess, struct, ctypes, re

# Key codes that should not disable the trackpoint since they may be
# used in combination, see /usr/include/linux/input.h.
MODIFIER_KEYS = ( 29, 56, 219, 184, 157, 42, 54 )

_32bit = ctypes.sizeof(ctypes.c_voidp) == 4
_eventFormat = _32bit and "=LLHHl" or "=qqHHl"
_eventFormatSize = struct.calcsize(_eventFormat)


class Trackpoint:
    def __init__(self, deviceName):
        self._deviceName = deviceName
        self._state = 1
    
    def switch(self, newState):
        subprocess.call(["/usr/bin/xinput",
                         "--set-prop",
                         "--type=int",
                         "--format=8",
                         self._deviceName,
                         "Device Enabled",
                         newState and "1" or "0"])
            
        self._state = newState
#        print newState and "ON" or "OFF"

    def on(self): self._state == 0 and self.switch(1)
    def off(self): self._state == 1 and self.switch(0)

def _parseDevices():
    mouse = None
    keyboardEvent = None

    nameRE = re.compile("N: Name=\"?(.*?)\"?$")
    handlersRE = re.compile("H: Handlers=(.*)")            
    eventRE = re.compile("event(\d)")

    f = open("/proc/bus/input/devices")

    try:
        while True:
            line = f.readline()

            if not line:
                break

            match = nameRE.match(line)

            if match:
                name = match.group(1)
                continue

            match = handlersRE.match(line)

            if match:
                handlers = match.group(1)

                if not mouse and "mouse" in handlers:
                    # Assume first mouse is the trackpoint.
                    mouse = name
                    
                elif not keyboardEvent and "sysrq" in handlers:
                    # Assume first device that handles sysrq is the
                    # laptop keyboard.
                    match = eventRE.search(handlers)
                    if match: keyboardEvent = int(match.group(1))
            
    finally:
        f.close()
    
    return mouse, keyboardEvent
    

if __name__ == "__main__":
    mouse, keyboardEvent =  _parseDevices()
    
    if not mouse or not keyboardEvent: raise "Failed to find devices"
        
    trackpoint = Trackpoint(mouse)

    def handler(signum, frame):
        if signum != signal.SIGALRM:
            trackpoint.switch(1)
            print "Terminating."
            sys.exit(0)
        else:
            trackpoint.on()
    
    [signal.signal(s, handler) for s in (signal.SIGTERM,
                                         signal.SIGQUIT,
                                         signal.SIGINT,
                                         signal.SIGALRM)]

    # the [Errno 4] Interrupted system call might be generated by SIGs above
    # http://www.velocityreviews.com/forums/t398973-ioerror-errno-4-interrupted-system-call.html
    while True:
        try:
            fd = os.open("/dev/input/event%d" % keyboardEvent, os.O_RDONLY)

            try:
                while True:
                    event = os.read(fd, _eventFormatSize)
                    _, _, etype, code, value = struct.unpack(_eventFormat, event)

                    if etype == 1 and code not in MODIFIER_KEYS: trackpoint.off()              
                    signal.setitimer(signal.ITIMER_REAL, 0.1, 0)
                      
            except OSError, e:
                # Ian added this check
                if e.errno != 4:
                    print e
                    raise e
            os.close(fd) # remember to close our open file, added by Ian
        except OSError, e:
            if e.errno != 24:
                raise e
            else:
                # The following happens sometimes and causes an exit 
                # OSError: [Errno 24] Too many open files: '/dev/input/event4'
                # this is probably because os.close(fd) didn't exist before several lines above
                # Added by Ian
                print "", e
                # NOTE that we don't come in here now the os.close(fd) line has been added above
